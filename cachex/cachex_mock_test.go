// Code generated by MockGen. DO NOT EDIT.
// Source: cachex.go
//
// Generated by this command:
//
//	mockgen -destination=cachex_mock.go -package=cachex -source=cachex.go Cacher
//

// Package cachex is a generated GoMock package.
package cachex

import (
	context "context"
	reflect "reflect"
	time "time"

	gomock "go.uber.org/mock/gomock"
)

// MockCacheBuilder is a mock of CacheBuilder interface.
type MockCacheBuilder[K any, V any] struct {
	ctrl     *gomock.Controller
	recorder *MockCacheBuilderMockRecorder[K, V]
	isgomock struct{}
}

// MockCacheBuilderMockRecorder is the mock recorder for MockCacheBuilder.
type MockCacheBuilderMockRecorder[K any, V any] struct {
	mock *MockCacheBuilder[K, V]
}

// NewMockCacheBuilder creates a new mock instance.
func NewMockCacheBuilder[K any, V any](ctrl *gomock.Controller) *MockCacheBuilder[K, V] {
	mock := &MockCacheBuilder[K, V]{ctrl: ctrl}
	mock.recorder = &MockCacheBuilderMockRecorder[K, V]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCacheBuilder[K, V]) EXPECT() *MockCacheBuilderMockRecorder[K, V] {
	return m.recorder
}

// Build mocks base method.
func (m *MockCacheBuilder[K, V]) Build() (CacheX[K, V], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Build")
	ret0, _ := ret[0].(CacheX[K, V])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Build indicates an expected call of Build.
func (mr *MockCacheBuilderMockRecorder[K, V]) Build() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Build", reflect.TypeOf((*MockCacheBuilder[K, V])(nil).Build))
}

// WithCacheNil mocks base method.
func (m *MockCacheBuilder[K, V]) WithCacheNil(cacheNil bool) CacheBuilder[K, V] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithCacheNil", cacheNil)
	ret0, _ := ret[0].(CacheBuilder[K, V])
	return ret0
}

// WithCacheNil indicates an expected call of WithCacheNil.
func (mr *MockCacheBuilderMockRecorder[K, V]) WithCacheNil(cacheNil any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithCacheNil", reflect.TypeOf((*MockCacheBuilder[K, V])(nil).WithCacheNil), cacheNil)
}

// WithCodec mocks base method.
func (m *MockCacheBuilder[K, V]) WithCodec(codec Codec[V]) CacheBuilder[K, V] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithCodec", codec)
	ret0, _ := ret[0].(CacheBuilder[K, V])
	return ret0
}

// WithCodec indicates an expected call of WithCodec.
func (mr *MockCacheBuilderMockRecorder[K, V]) WithCodec(codec any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithCodec", reflect.TypeOf((*MockCacheBuilder[K, V])(nil).WithCodec), codec)
}

// WithDelTTL mocks base method.
func (m *MockCacheBuilder[K, V]) WithDelTTL(ttl time.Duration) CacheBuilder[K, V] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithDelTTL", ttl)
	ret0, _ := ret[0].(CacheBuilder[K, V])
	return ret0
}

// WithDelTTL indicates an expected call of WithDelTTL.
func (mr *MockCacheBuilderMockRecorder[K, V]) WithDelTTL(ttl any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithDelTTL", reflect.TypeOf((*MockCacheBuilder[K, V])(nil).WithDelTTL), ttl)
}

// WithExpireTTL mocks base method.
func (m *MockCacheBuilder[K, V]) WithExpireTTL(ttl time.Duration) CacheBuilder[K, V] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithExpireTTL", ttl)
	ret0, _ := ret[0].(CacheBuilder[K, V])
	return ret0
}

// WithExpireTTL indicates an expected call of WithExpireTTL.
func (mr *MockCacheBuilderMockRecorder[K, V]) WithExpireTTL(ttl any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithExpireTTL", reflect.TypeOf((*MockCacheBuilder[K, V])(nil).WithExpireTTL), ttl)
}

// WithGenKeyFn mocks base method.
func (m *MockCacheBuilder[K, V]) WithGenKeyFn(fn GenKeyFn[K]) CacheBuilder[K, V] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithGenKeyFn", fn)
	ret0, _ := ret[0].(CacheBuilder[K, V])
	return ret0
}

// WithGenKeyFn indicates an expected call of WithGenKeyFn.
func (mr *MockCacheBuilderMockRecorder[K, V]) WithGenKeyFn(fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithGenKeyFn", reflect.TypeOf((*MockCacheBuilder[K, V])(nil).WithGenKeyFn), fn)
}

// WithL1 mocks base method.
func (m *MockCacheBuilder[K, V]) WithL1(cacher Cacher) CacheBuilder[K, V] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithL1", cacher)
	ret0, _ := ret[0].(CacheBuilder[K, V])
	return ret0
}

// WithL1 indicates an expected call of WithL1.
func (mr *MockCacheBuilderMockRecorder[K, V]) WithL1(cacher any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithL1", reflect.TypeOf((*MockCacheBuilder[K, V])(nil).WithL1), cacher)
}

// WithL2 mocks base method.
func (m *MockCacheBuilder[K, V]) WithL2(cacher Cacher) CacheBuilder[K, V] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithL2", cacher)
	ret0, _ := ret[0].(CacheBuilder[K, V])
	return ret0
}

// WithL2 indicates an expected call of WithL2.
func (mr *MockCacheBuilderMockRecorder[K, V]) WithL2(cacher any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithL2", reflect.TypeOf((*MockCacheBuilder[K, V])(nil).WithL2), cacher)
}

// WithLoader mocks base method.
func (m *MockCacheBuilder[K, V]) WithLoader(fn LoaderFn[K, V]) CacheBuilder[K, V] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithLoader", fn)
	ret0, _ := ret[0].(CacheBuilder[K, V])
	return ret0
}

// WithLoader indicates an expected call of WithLoader.
func (mr *MockCacheBuilderMockRecorder[K, V]) WithLoader(fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithLoader", reflect.TypeOf((*MockCacheBuilder[K, V])(nil).WithLoader), fn)
}

// WithMultiLoader mocks base method.
func (m *MockCacheBuilder[K, V]) WithMultiLoader(fn MultiLoaderFn[K, V]) CacheBuilder[K, V] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithMultiLoader", fn)
	ret0, _ := ret[0].(CacheBuilder[K, V])
	return ret0
}

// WithMultiLoader indicates an expected call of WithMultiLoader.
func (mr *MockCacheBuilderMockRecorder[K, V]) WithMultiLoader(fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithMultiLoader", reflect.TypeOf((*MockCacheBuilder[K, V])(nil).WithMultiLoader), fn)
}

// WithNamespace mocks base method.
func (m *MockCacheBuilder[K, V]) WithNamespace(namespace string) CacheBuilder[K, V] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithNamespace", namespace)
	ret0, _ := ret[0].(CacheBuilder[K, V])
	return ret0
}

// WithNamespace indicates an expected call of WithNamespace.
func (mr *MockCacheBuilderMockRecorder[K, V]) WithNamespace(namespace any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithNamespace", reflect.TypeOf((*MockCacheBuilder[K, V])(nil).WithNamespace), namespace)
}

// WithSourceStrategy mocks base method.
func (m *MockCacheBuilder[K, V]) WithSourceStrategy(ss SourceStrategy) CacheBuilder[K, V] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithSourceStrategy", ss)
	ret0, _ := ret[0].(CacheBuilder[K, V])
	return ret0
}

// WithSourceStrategy indicates an expected call of WithSourceStrategy.
func (mr *MockCacheBuilderMockRecorder[K, V]) WithSourceStrategy(ss any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithSourceStrategy", reflect.TypeOf((*MockCacheBuilder[K, V])(nil).WithSourceStrategy), ss)
}

// MockCacheX is a mock of CacheX interface.
type MockCacheX[K any, V any] struct {
	ctrl     *gomock.Controller
	recorder *MockCacheXMockRecorder[K, V]
	isgomock struct{}
}

// MockCacheXMockRecorder is the mock recorder for MockCacheX.
type MockCacheXMockRecorder[K any, V any] struct {
	mock *MockCacheX[K, V]
}

// NewMockCacheX creates a new mock instance.
func NewMockCacheX[K any, V any](ctrl *gomock.Controller) *MockCacheX[K, V] {
	mock := &MockCacheX[K, V]{ctrl: ctrl}
	mock.recorder = &MockCacheXMockRecorder[K, V]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCacheX[K, V]) EXPECT() *MockCacheXMockRecorder[K, V] {
	return m.recorder
}

// Del mocks base method.
func (m *MockCacheX[K, V]) Del(ctx context.Context, key K) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Del", ctx, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// Del indicates an expected call of Del.
func (mr *MockCacheXMockRecorder[K, V]) Del(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Del", reflect.TypeOf((*MockCacheX[K, V])(nil).Del), ctx, key)
}

// Get mocks base method.
func (m *MockCacheX[K, V]) Get(ctx context.Context, key K) (*V, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, key)
	ret0, _ := ret[0].(*V)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockCacheXMockRecorder[K, V]) Get(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCacheX[K, V])(nil).Get), ctx, key)
}

// MDel mocks base method.
func (m *MockCacheX[K, V]) MDel(ctx context.Context, keys []K) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MDel", ctx, keys)
	ret0, _ := ret[0].(error)
	return ret0
}

// MDel indicates an expected call of MDel.
func (mr *MockCacheXMockRecorder[K, V]) MDel(ctx, keys any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MDel", reflect.TypeOf((*MockCacheX[K, V])(nil).MDel), ctx, keys)
}

// MGet mocks base method.
func (m *MockCacheX[K, V]) MGet(ctx context.Context, keys []K) ([]*V, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MGet", ctx, keys)
	ret0, _ := ret[0].([]*V)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MGet indicates an expected call of MGet.
func (mr *MockCacheXMockRecorder[K, V]) MGet(ctx, keys any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MGet", reflect.TypeOf((*MockCacheX[K, V])(nil).MGet), ctx, keys)
}

// MSet mocks base method.
func (m *MockCacheX[K, V]) MSet(ctx context.Context, keys []K, values []*V) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MSet", ctx, keys, values)
	ret0, _ := ret[0].(error)
	return ret0
}

// MSet indicates an expected call of MSet.
func (mr *MockCacheXMockRecorder[K, V]) MSet(ctx, keys, values any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MSet", reflect.TypeOf((*MockCacheX[K, V])(nil).MSet), ctx, keys, values)
}

// Set mocks base method.
func (m *MockCacheX[K, V]) Set(ctx context.Context, key K, value *V) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Set", ctx, key, value)
	ret0, _ := ret[0].(error)
	return ret0
}

// Set indicates an expected call of Set.
func (mr *MockCacheXMockRecorder[K, V]) Set(ctx, key, value any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockCacheX[K, V])(nil).Set), ctx, key, value)
}

// WithSourceStrategy mocks base method.
func (m *MockCacheX[K, V]) WithSourceStrategy(ss SourceStrategy) CacheX[K, V] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithSourceStrategy", ss)
	ret0, _ := ret[0].(CacheX[K, V])
	return ret0
}

// WithSourceStrategy indicates an expected call of WithSourceStrategy.
func (mr *MockCacheXMockRecorder[K, V]) WithSourceStrategy(ss any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithSourceStrategy", reflect.TypeOf((*MockCacheX[K, V])(nil).WithSourceStrategy), ss)
}

// MockCacher is a mock of Cacher interface.
type MockCacher struct {
	ctrl     *gomock.Controller
	recorder *MockCacherMockRecorder
	isgomock struct{}
}

// MockCacherMockRecorder is the mock recorder for MockCacher.
type MockCacherMockRecorder struct {
	mock *MockCacher
}

// NewMockCacher creates a new mock instance.
func NewMockCacher(ctrl *gomock.Controller) *MockCacher {
	mock := &MockCacher{ctrl: ctrl}
	mock.recorder = &MockCacherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCacher) EXPECT() *MockCacherMockRecorder {
	return m.recorder
}

// Delete mocks base method.
func (m *MockCacher) Delete(ctx context.Context, key string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockCacherMockRecorder) Delete(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockCacher)(nil).Delete), ctx, key)
}

// Get mocks base method.
func (m *MockCacher) Get(ctx context.Context, key string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, key)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockCacherMockRecorder) Get(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCacher)(nil).Get), ctx, key)
}

// MDelete mocks base method.
func (m *MockCacher) MDelete(ctx context.Context, keys []string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MDelete", ctx, keys)
	ret0, _ := ret[0].(error)
	return ret0
}

// MDelete indicates an expected call of MDelete.
func (mr *MockCacherMockRecorder) MDelete(ctx, keys any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MDelete", reflect.TypeOf((*MockCacher)(nil).MDelete), ctx, keys)
}

// MGet mocks base method.
func (m *MockCacher) MGet(ctx context.Context, keys []string) (map[string][]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MGet", ctx, keys)
	ret0, _ := ret[0].(map[string][]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MGet indicates an expected call of MGet.
func (mr *MockCacherMockRecorder) MGet(ctx, keys any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MGet", reflect.TypeOf((*MockCacher)(nil).MGet), ctx, keys)
}

// MSet mocks base method.
func (m *MockCacher) MSet(ctx context.Context, kvs map[string][]byte, ttl time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MSet", ctx, kvs, ttl)
	ret0, _ := ret[0].(error)
	return ret0
}

// MSet indicates an expected call of MSet.
func (mr *MockCacherMockRecorder) MSet(ctx, kvs, ttl any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MSet", reflect.TypeOf((*MockCacher)(nil).MSet), ctx, kvs, ttl)
}

// Set mocks base method.
func (m *MockCacher) Set(ctx context.Context, key string, val []byte, ttl time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Set", ctx, key, val, ttl)
	ret0, _ := ret[0].(error)
	return ret0
}

// Set indicates an expected call of Set.
func (mr *MockCacherMockRecorder) Set(ctx, key, val, ttl any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockCacher)(nil).Set), ctx, key, val, ttl)
}
